{
  "name": "postcss",
  "version": "4.0.1",
  "description": "Framework for CSS postprocessors with full source map support",
  "keywords": [
    "css",
    "parser",
    "postproccessor",
    "source map"
  ],
  "author": {
    "name": "Andrey Sitnik",
    "email": "andrey@sitnik.ru"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/postcss/postcss.git"
  },
  "dependencies": {
    "source-map": "~0.1.43",
    "js-base64": "~2.1.6"
  },
  "devDependencies": {
    "concat-with-sourcemaps": "1.0.0",
    "gulp-bench-summary": "0.1.0",
    "gulp-json-editor": "2.2.1",
    "jshint-stylish": "1.0.0",
    "gulp-jshint": "1.9.0",
    "gonzales-pe": "3.0.0-12",
    "gulp-bench": "1.1.0",
    "gulp-mocha": "2.0.0",
    "gulp-util": "3.0.2",
    "gulp-6to5": "2.0.0",
    "node-sass": "1.2.3",
    "execSync": "1.0.2",
    "fs-extra": "0.14.0",
    "gonzales": "1.0.7",
    "stylecow": "4.0.1",
    "through2": "0.6.3",
    "request": "2.51.0",
    "cssnext": "0.6.6",
    "rework": "1.0.1",
    "mensch": "0.3.1",
    "stylus": "0.49.3",
    "mocha": "2.1.0",
    "cssom": "0.3.0",
    "gulp": "3.8.10",
    "less": "2.2.0",
    "chai": "1.10.0",
    "6to5": "2.9.4"
  },
  "scripts": {
    "test": "gulp"
  },
  "main": "lib/postcss",
  "readme": "# PostCSS [![Build Status](https://travis-ci.org/postcss/postcss.svg)](https://travis-ci.org/postcss/postcss) [![Gitter](https://badges.gitter.im/Join Chat.svg)](https://gitter.im/postcss/postcss?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n<img align=\"right\" width=\"95\" height=\"95\" src=\"http://postcss.github.io/postcss/logo.svg\" title=\"Philosopher’s stone, logo of PostCSS\">\n\nPostCSS is a framework for CSS postprocessors,\nto modify CSS with JavaScript with full source map support.\n\nIt takes care of the most common CSS tool tasks:\n\n1. parses CSS;\n2. provides a usable JS API to edit CSS node trees;\n3. dumps the modified node tree into a CSS string;\n4. generates a source map (or modifies an pre-existing source map) containing\n   your changes;\n\nYou can use this framework to write your own:\n\n* CSS minifier or beautifier.\n* CSS polyfills.\n* Grunt plugin to generate sprites, include `data-uri` images\n  or any other work.\n* Text editor plugin to automate CSS routines.\n* Command-line CSS tool.\n\nTwitter account for news, releases and new plugins: [@postcss].\nWeibo account: [postcss].\n\n<a href=\"https://evilmartians.com/?utm_source=postcss\">\n<img src=\"https://evilmartians.com/badges/sponsored-by-evil-martians.svg\" alt=\"Sponsored by Evil Martians\" width=\"236\" height=\"54\">\n</a>\n\n[@postcss]: https://twitter.com/postcss\n[postcss]:  http://weibo.com/postcss\n\n## Built with PostCSS\n\n### Tools\n\n* [Autoprefixer] adds vendor prefixes by Can I Use data.\n* [BEM linter] lints CSS for SUIT CSS methodology.\n* [CSS MQPacker] joins same media queries.\n* [css2modernizr] analyzes your CSS and output only used Modernizr’s settings.\n* [cssnext] is a transpiler (CSS 4+ to CSS 3) that allow you to use tomorrow’s\n  CSS syntax today.\n* [CSSWring] is a CSS minifier with full source map support.\n* [data-separator] splits data-uri into a separate CSS file.\n* [pixrem] is a `rem` unit polyfill.\n* [webpcss] to duplicate images in CSS to WebP for supported browsers.\n* [Pleeease] is a pack of various postprocessors.\n* [Pleeease Filters] converts WebKit filters to SVG filter for other browsers.\n* [RTLCSS] mirrors styles for right-to-left locales.\n* [CSS Byebye] explicitly removes the CSS rules that you don’t want.\n* [postcss-epub] to prefix ePub3 properties.\n* [doiuse] to lint your CSS on unsupported properties by Can I Use.\n* [postcss-assets] to inline files and insert image width and height.\n* [ACSS] Annotations based CSS processor.\n* [CSS Grace] to CSS 3 polyfills for IE and other old browsers.\n* [mq4-hover-hover-shim] is a shim for the `hover` media feature from Media\n  Queries Level 4.\n\n[Autoprefixer]:         https://github.com/postcss/autoprefixer\n[BEM linter]:           https://github.com/necolas/postcss-bem-linter\n[CSS MQPacker]:         https://github.com/hail2u/node-css-mqpacker\n[css2modernizr]:        https://github.com/vovanbo/css2modernizr\n[cssnext]:              https://github.com/putaindecode/cssnext\n[CSSWring]:             https://github.com/hail2u/node-csswring\n[data-separator]:       https://github.com/Sebastian-Fitzner/grunt-data-separator\n[pixrem]:               https://github.com/robwierzbowski/node-pixrem\n[webpcss]:              https://github.com/lexich/webpcss\n[Pleeease]:             http://pleeease.io/\n[Pleeease Filters]:     https://github.com/iamvdo/pleeease-filters\n[RTLCSS]:               https://github.com/MohammadYounes/rtlcss\n[CSS Byebye]:           https://github.com/AoDev/css-byebye\n[postcss-epub]:         https://github.com/Rycochet/postcss-epub\n[doiuse]:               https://github.com/anandthakker/doiuse\n[postcss-assets]:       https://github.com/borodean/postcss-assets\n[ACSS]:                 https://github.com/morishitter/acss\n[CSS Grace]:            https://github.com/cssdream/cssgrace\n[mq4-hover-hover-shim]: https://github.com/cvrebert/mq4-hover-hover-shim\n\n### Plugins\n\n* [postcss-calc] to reduce `calc()` usage\n  (recommended with `postcss-custom-properties`).\n* [postcss-color-function] to transform `color()` function.\n* [postcss-color-gray] to transform `gray()` function.\n* [postcss-color-hex-alpha] to transform hexadecimal notations with alpha\n  (`#rrggbbaa` or `#rgba`).\n* [postcss-color-hwb] to transform `hwb()` function.\n* [postcss-color-rebeccapurple] to transform `rebeccapurple` color.\n* [postcss-import] to transform `@import` rules by inlining content.\n* [postcss-custom-media] to add names for Media Queries.\n* [postcss-custom-properties] to transform Custom Properties\n  for cascading variables.\n* [postcss-url] to rebase or inline on `url()`.\n* [postcss-font-variant] to set `font-feature-settings` by readable properties.\n* [postcss-nested] to unwrap rules in other rules, like you can write in Sass.\n* [postcss-custom-selector] to add custom alias for selectors.\n* [postcss-media-minmax] to use `<=` or `>=` in CSS Media Queries.\n* [postcss-data-packer] to move an embedded data into a separate file.\n* [postcss-color-palette] to transform CSS2 color keywords to a custom palette.\n* [postcss-color-hex] to transform rgb() and rgba() to hex.\n* [postcss-single-charset] to pop first `@charset` rule.\n\n[postcss-calc]:                 https://github.com/postcss/postcss-calc\n[postcss-color-function]:       https://github.com/postcss/postcss-color-function\n[postcss-color-gray]:           https://github.com/postcss/postcss-color-gray\n[postcss-color-hex-alpha]:      https://github.com/postcss/postcss-color-hex-alpha\n[postcss-color-hwb]:            https://github.com/postcss/postcss-color-hwb\n[postcss-color-rebeccapurple]:  https://github.com/postcss/postcss-color-rebeccapurple\n[postcss-import]:               https://github.com/postcss/postcss-import\n[postcss-custom-media]:         https://github.com/postcss/postcss-custom-media\n[postcss-custom-properties]:    https://github.com/postcss/postcss-custom-properties\n[postcss-url]:                  https://github.com/postcss/postcss-url\n[postcss-font-variant]:         https://github.com/postcss/postcss-font-variant\n[postcss-nested]:               https://github.com/postcss/postcss-nested\n[postcss-custom-selector]:      https://github.com/postcss/postcss-custom-selector\n[postcss-media-minmax]:         https://github.com/postcss/postcss-media-minmax\n[postcss-data-packer]:          https://github.com/Ser-Gen/postcss-data-packer\n[postcss-color-palette]:        https://github.com/zaim/postcss-color-palette\n[postcss-color-hex]:            https://github.com/TrySound/postcss-color-hex\n[postcss-single-charset]:       https://github.com/hail2u/postcss-single-charset\n\n## Quick Example\n\nLet’s fix a forgotten `content` property in `::before` and `::after`:\n\n```js\nvar postcss = require('postcss');\n\nvar contenter = postcss(function (css) {\n    css.eachRule(function (rule) {\n        if ( rule.selector.match(/::(before|after)/) ) {\n            // In each ::before/::after rule\n\n            // Did we forget the content property?\n            var good = rule.some(function (i) { return i.prop == 'content'; });\n\n            if ( !good ) {\n                // Add content: \"\" if we forget it\n                rule.prepend({ prop: 'content', value: '\"\"' });\n            }\n\n        }\n    });\n});\n```\n\nAnd the CSS with a forgotten `content` property:\n\n```css\na::before {\n    width: 10px;\n    height: 10px\n}\n```\n\nwill be fixed by our new `contenter`:\n\n```js\nvar fixed = contenter.process(css).css;\n```\n\nto:\n\n```css\na::before {\n    content: \"\";\n    width: 10px;\n    height: 10px\n}\n```\n\n## Features\n\n### Source Map\n\nPostCSS generates a source map of its changes:\n\n```js\nresult = processor.process(css, { map: true, from: 'from.css', to: 'to.css' });\nresult.css // String with processed CSS and inlined source map\n```\n\nAnd modifies a source map from previous steps (for example, Sass preprocessor):\n\n```js\nvar sass = compiler.compile(sass);\n\nprocessor.process(sass.css, {\n    map:  { prev: sass.map },\n    from: 'from.sass.css',\n    to:   'to.css'\n});\n```\n\n### Preserves code formatting and indentations\n\nPostCSS will not change any byte of a rule, if you do not modify its node:\n\n```js\npostcss(function (css) { }).process(css).css == css;\n```\n\nAnd when you modify CSS nodes, PostCSS will try to copy the coding style:\n\n```js\ncontenter.process(\"a::before{color:black}\")\n// a::before{content:'';color:black}\n\ncontenter.process(\"a::before {\\n  color: black;\\n  }\")\n// a::before {\n//   content: '';\n//   color: black;\n//   }\n```\n\nWhich allows you to use PostCSS in text editor plugins while preserving\nthe user’s code style.\n\n## Why PostCSS Better Than …\n\n### Preprocessors\n\nPreprocessors (like Sass or Stylus) give us special languages with variables,\nmixins, and statements, which are compiled to CSS. Compass, nib and other mixins\nlibraries use these languages to work with prefixes, sprites and inline images.\n\nBut the Sass and Stylus languages were created to be syntax-sugar for CSS.\nWriting complicated programs using preprocessor languages can be very difficult.\nFor example, it would be impossible to implement [Autoprefixer] on top of Sass.\n\nPostCSS gives you the comfort and power of JS or CoffeeScript while\nyou are working with CSS. Applying the depth and variety of [npm]’s libraries\nallows you to perform quite magical things using PostCSS.\n\nAn important point is that postprocessors are not the enemies of preprocessors.\nPreprocessors and postprocessors can be easily combined, so that you can take\nadvantage of the readability and syntactical sugar offered by Sass and Stylus;\nand PostCSS will preserve their source maps.\n\n[Autoprefixer]: https://github.com/postcss/autoprefixer\n[npm]:          https://npmjs.org/\n\n### Regular Expressions\n\nSome Grunt plugins modify CSS with regular expressions, however a parser\nand its node tree provide a much safer interface to edit CSS. Furthermore,\nregular expressions typically break the source maps generated by preprocessors.\n\n### CSS Parsers\n\nThere are a lot of good CSS parsers, such as [Gonzales], but they only help you\nto read in the CSS. PostCSS provides you with full source map support and a\nhigh level API. Safe iterators, and other features, are unique to PostCSS.\n\n[Gonzales]: https://github.com/css/gonzales\n\n### Rework\n\n[Rework] and PostCSS are very similar, but they have different targets.\n\nRework was created to build a new CSS sublanguage that replaced Stylus\n(like [Myth]). PostCSS was created for CSS tools which work with legacy CSS code\n(one such tool is Autoprefixer).\n\nBecause of this fundamental difference, PostCSS:\n\n* Handles source map better, because it updates the map from the previous step\n  (for example, Sass compilation).\n* Preserves all your spaces and code style, so that it can function\n  in text editor plugins.\n* Has a safer parser, so that it can be used for legacy code. Only PostCSS can\n  parse all of the hacks from [Browserhacks.com](http://browserhacks.com/).\n* Has a high level API to provide an simple interface for your processor to\n  perform typical tasks.\n\n[Myth]:   http://www.myth.io/\n[Rework]: https://github.com/visionmedia/rework\n\n## Usage\n\n### Grunt\n\nGrunt plugin [grunt-postcss] allows you to pipe your CSS files through\nan array of PostCSS processors.\n\n```js\ngrunt.initConfig({\n    postcss: {\n        options: {\n            map: true,\n            processors: [\n                require('autoprefixer-core').postcss,\n                require('csswring').postcss\n            ]\n        },\n        dist: {\n            src: 'css/*.css'\n        }\n    }\n});\n\ngrunt.loadNpmTasks('grunt-postcss');\n```\n\n[grunt-postcss]: https://github.com/nDmitry/grunt-postcss\n\n### Gulp\n\nThere is a Gulp plugin for PostCSS called [gulp-postcss] that allows you\nto pipe your CSS files through an array of PostCSS processors.\n\nSupport for external source maps is provided by [gulp-sourcemaps].\n\n```js\nvar postcss    = require('gulp-postcss');\nvar sourcemaps = require('gulp-sourcemaps');\n\ngulp.task('css', function () {\n    var processors = [\n        require('autoprefixer-core'),\n        require('csswring')\n     ];\n     return gulp.src('./src/*.css')\n        .pipe(sourcemaps.init())\n        .pipe(postcss(processors))\n        .pipe(sourcemaps.write('.'))\n        .pipe(gulp.dest('./dest'));\n});\n```\n\n[gulp-postcss]:    https://github.com/w0rm/gulp-postcss\n[gulp-sourcemaps]: https://github.com/floridoo/gulp-sourcemaps\n\n### Webpack\n\nIn [webpack] you can use [postcss-loader] to process CSS files through\nan array of PostCSS processors.\n\n```js\nmodule.exports = {\n    module: {\n        loaders: [\n            {\n                test:   /\\.css$/,\n                loader: \"style-loader!css-loader!postcss-loader\"\n            }\n        ]\n    },\n    postcss: [require('autoprefixer-core'), require('csswring')]\n}\n```\n\n[postcss-loader]: https://github.com/postcss/postcss-loader\n[webpack]:        http://webpack.github.io/\n\n## Write Own Processor\n\nYou can parse CSS with the `postcss.parse()` method, which returns a CSS AST:\n\n```js\nvar postcss = require('postcss');\n\nvar css = postcss.parse('a { color: black }');\n```\n\nYou can easily make changes to this AST. Use `css.nodes` to get children.\nProperties `rule.selector`, `decl.prop`, `decl.value`, `atrule.name`\nand `atrule.params` contain data.\n\n```js\ncss.nodes[0].value = 'white';\n```\n\nAfter changes have been made you can get the new CSS and a source map reflecting\nthe modifications:\n\n```js\nvar result = css.toResult(options);\n\nresult.css //=> 'a { color: white }'\nresult.map //=> '{\"version\":3, … }'\n```\n\nThe methods `postcss.parse()` and `CSS#toResult()` are part of a low level API,\nand - in most cases - it will be better to create processors with a simpler API\nand chaining.\n\n### Processor\n\nThe function `postcss(fn)` creates a processor from your function:\n\n```js\nvar postcss = require('postcss');\n\nvar processor = postcss(function (css, opts) {\n    // Code to modify CSS\n});\n```\n\nIf you want to combine multiple processors (and parse the CSS only once),\nyou can add several functions using the `use(fn)` method:\n\n```js\nvar all = postcss().\n          use(prefixer).\n          use(minifing);\n```\n\nYou can also add processor objects with the `postcss` function:\n\n```js\npostcss().use( autoprefixer.postcss ); // via function\npostcss().use( autoprefixer );         // via object\n```\n\nA processor function can change the current CSS node tree:\n\n```js\npostcss(function (css) {\n    css.append( /* new rule */ )\n});\n```\n\nor create a completely new CSS root node and return it instead:\n\n```js\npostcss(function (css) {\n    var newCSS = postcss.root()\n    // Add rules and declarations\n    return newCSS;\n});\n```\n\nThis generated processor transforms some CSS using\nthe `process(css, opts)` method:\n\n```js\nvar doubler = postcss(function (css) {\n    // Clone each declaration\n    css.eachDecl(function (decl) {\n        decl.parent.prepend( decl.clone() );\n    });\n});\n\nvar css    = \"a { color: black; }\";\nvar result = doubler.process(css);\n\nresult.css //=> \"a { color: black; color: black; }\"\n```\n\nYou can change the original CSS filename via the `from` option, which\ncan make syntax error more helpful:\n\n```js\nvar wrong = \"a {\";\nprocessor.process(wrong, { from: 'main.css' });\n//=> Can't parse CSS: Unclosed block at line 1:1 in main.css\n```\n\nOptions from `process(css, opts)` will be sent to processors\nas the second argument.\n\nYou can also use the result from a previous postprocessor, or\nan already-parsed `Root`, as an argument to the next one:\n\n```js\nresult = processor1.process(css)\nprocessor2.process(result)\n```\n\n### Multiple Inputs\n\nThe function `postcss()` generates a processor for only one input.\nIf you need to process several inputs (for example, when concatenating files)\nyou can use `postcss.parse()`.\n\nLet’s join two CSS strings with full source map support in only 5 lines of code:\n\n```js\nvar file1 = postcss.parse(css1, { from: 'a.css' });\nvar file2 = postcss.parse(css2, { from: 'b.css' });\n\nfile1.append( file2 );\n\nvar result = file1.toResult({ to: 'app.css', map: true });\n```\n\n### Source Map\n\nBy using [source maps], a browser’s development tools can indicate the\noriginal position of your styles before the css file was transformed.\nFor example, an inspector will show the position in a Sass file, even if\nthe file has been compiled to CSS, concatenated, and minified.\n\nTo ensure a correct source map is generated, every CSS processing step should\nupdate the map generated by the previous step. For example, a Sass compiler\nwill generate the first map, a concatenation tool should update the Sass step’s\nmap, and a minifier should update the map generated by the concatenation tool.\n\nThere are two ways to store a source map:\n\n* You can place it in a separate file which contains a special annotation\n  comments pointing to another file:\n\n  ```css\n a { }\n /*# sourceMappingURL=main.out.css.map */\n  ```\n* Or you can inline a base64-encoded source map within a CSS comment:\n\n  ```css\n a { }\n /*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uY3NzIiwic291cmNlcyI6WyJtYWluLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFLIn0= */\n  ```\n\nPostCSS has great source map support. To ensure that you generate the correct\nsource map, you must indicate the input and output CSS files\npaths (using the options `from` and `to` respectively).\n\nTo generate a new source map with the default options, provide `map: true`.\nThis will inline sourcemap with source content.\n\nIf you don't want the map inlined, you can use `inline: false`\nin the options passed to `processor.process(css, opts)`.\n\n```js\nvar result = processor.process(css, {\n    from: 'main.css',\n    to:   'main.out.css'\n    map: { inline: false },\n});\n\nresult.map //=> '{\"version\":3,\"file\":\"main.out.css\",\"sources\":[\"main.css\"],\"names\":[],\"mappings\":\"AAAA,KAAI\"}'\n\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nOr set `from` in `postcss.parse(css, opts)` and `to` in `root.toResult(opts)`:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css', { inline: false } });\nroot.last.removeSelf(); // Example transformation\n\nvar result = root.toResult({ to: 'main.out.css' });\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nIf PostCSS is handling CSS and finds source maps from previous transformations,\nit will automatically update the CSS with the same options.\n\n```js\n// main.sass.css has an annotation comment with a link to main.sass.css.map\nvar result = minifier.process(css, { from: 'main.sass.css', to: 'main.min.css' });\nresult.map //=> Source map from main.sass to main.min.css\n```\n\nIf you want more control over source map generation, you can define the `map`\noption as an object with the following parameters:\n\n* `inline` (boolean): indicates the source map should be inserted into the CSS\n  base64 string as a comment. By default it is `true`. But if all previous map\n  are in separated too, PostCSS will not inline map too.\n\n  If you inline a source map, `result.map` will be empty, as the source map\n  will be contained within the text of `result.css`.\n\n* `prev` (string, object, or boolean): map content from a previous processing\n  step (for example, Sass compilation). PostCSS will try to read the previous\n  source map automatically from the comment within origin CSS, but you can also\n  set manually. If desired, you can omit the previous map with `prev: false`.\n\n  This is a source map option which can be passed to `postcss.parse(css, opts)`.\n  Other options can be passed to the `toResult(opts)` or `process(css, opts)`\n  methods.\n\n* `sourcesContent` (boolean): indicates that we should set the origin content\n  (for example, Sass source) of the source map. By default it is `true`.\n  But if all previous map do not contain sources content,\n  PostCSS will miss it too.\n\n* `annotation` (boolean or string): indicates if we should add annotation\n  comments to the CSS. By default, PostCSS will always add a comment with a path\n  to the source map. But if the previous CSS does not have an annotation\n  comment, PostCSS will omit it too.\n\n  By default, PostCSS presumes that you want to save the source map as\n  `opts.to + '.map'` and will use this path in the annotation comment.\n  But you can set another path by providing a string value as the `annotation`\n  option.\n\n  If you set `inline: true`, annotation cannot be disabled.\n\n[source maps]: http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/\n\n### Safe Mode\n\nIf you provide a `safe: true` option to the `process` or `parse` methods,\nPostCSS will try to correct any syntax error that it finds in the CSS.\nFor example, it will parse `a {` as `a {}`.\n\n```js\npostcss.parse('a {');                 // will throw \"Unclosed block\"\npostcss.parse('a {', { safe: true }); // will return CSS root for a {}\n```\n\nThis is useful for legacy code filled with plenty of hacks. Another use case\nis interactive tools with live input, for example,\nthe [Autoprefixer demo](http://jsfiddle.net/simevidas/udyTs/show/light/).\n\n### Helpers\n\n#### Vendor\n\nPostCSS contains height optimized code to split vendor prefix:\n\n```js\nvar vendor = require('postcss/lib/vendor');\n\nvendor.prefix('-moz-tab-size')     //=> '-moz-'\nvendor.unprefixed('-moz-tab-size') //=> 'tab-size'\n```\n\n#### List\n\nTo safely split comma- or space-separated values (such as those\nin `background-image` or `transform`) with brackets and quotes support,\nyou can use the `list` helper:\n\n```js\nvar list = require('postcss/lib/list');\n\nlist.space(image.value)     //=> ['linear-gradient(white, black)', 'blue']\nlist.comma(transform.value) //=> ['color 200ms', 'background 200ms']\n```\n\n### Nodes\n\nProcessor functions receive a `Root` node which contains the CSS node tree.\n\n```js\nvar processor = postcss(function (cssRoot) {\n});\n```\n\nThere are 4 types of child nodes: `Comment`, `AtRule`, `Rule` and `Declaration`.\nAll nodes possess `toString()` and `clone()` methods.\n\nYou can parse CSS and get a `Root` node by calling\nthe `postcss.parse(css, opts)` method:\n\n```js\nvar cssRoot = postcss.parse('a { }');\n```\n\nMany of the methods on a node will return the current node, which enables\nyou to build method chains:\n\n```js\nroot.append( rule1 ).append( rule2 ).toString();\n```\n\nIf some node broke you plugin syntax you can throw CSS syntax error:\n\n```js\nthrow node.error('Bad variable syntax');\n//=> CssSyntaxError: app.css:45:5: Bad variable syntax\n//   var-name: 1\n//   ^\n```\n\n### Node Source\n\nEvery node stores its origin file (if you provide the `from` option\nto the `process` or `parse` methods) and position:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nvar rule = root.nodes[0];\n\nrule.source.input.file //=> 'main.css'\nrule.source.start      //=> { line: 5,  position: 1 }\nrule.source.end        //=> { line: 10, position: 5 }\n```\n\n### Whitespace\n\nAll nodes (excluding the `Root`) have a `before` property which contains\nthe indentation and any previous whitespace.\n\nNodes with children (`Root`, `AtRule` and `Rule`) also contain an `after`\nproperty which indicates the spaces after the last child and before a `}`\ncharacter or the end of the file.\n\nEvery `Declaration` has a `between` property with colon, spaces and comments\nbetween the property name and value. `Rule` stores the spaces and comments\nbetween the selector and `{` in the `between` property. `AtRule` uses `between`\nto indicate the spaces and comments before either a `{` or `;`, if the at-rule\nis bodiless.\n\n```js\nvar root = postcss.parse(\"a {\\n  color: black;\\n}\\n\");\n\nroot.nodes[0].between          //=> \" \" between selector and {\nroot.nodes[0].nodes[0].before  //=> \"\\n  \" before color: black\nroot.nodes[0].nodes[0].between //=> \": \" between property name and value\nroot.nodes[0].after            //=> \"\\n\" before }\nroot.after                     //=> \"\\n\" from end of file\n```\n\nThe simplest way to minify CSS is to set `before`, `between` and `after`\nproperties to an empty string:\n\n```js\nvar minifier = postcss(function (css) {\n    css.eachDecl(function (decl) {\n        decl.before  = '';\n        decl.between = ':';\n    });\n    css.eachRule(function (rule) {\n        rule.before  = '';\n        rule.between = '';\n        rule.after   = '';\n    });\n    css.eachAtRule(function (atRule) {\n        atRule.before  = '';\n        atRule.between = '';\n        atRule.after   = '';\n    });\n    css.eachComment(function (comment) {\n        comment.removeSelf();\n    });\n});\n\nvar css = \"a {\\n  color:black\\n}\\n\";\nminifier.process(css).css //=> \"a{color:black}\"\n```\n\nNote that nodes may have not `before` or `between` properties:\n\n* If node was created by hand via `postcss.rule()`.\n* `node.clone()` will clean all style properties to use the style\n  for a new CSS root.\n\n### Raw Properties\n\nSome CSS values (selectors, comment text, at-rule params and declaration values)\ncan contain comments. PostCSS will clean them to remove trailing spaces:\n\n```js\nvar root = postcss.parse(\"a /**/ b {}\");\nvar rule = root.first;\n\nrule.selector      //=> 'a  b' trimmed and cleaned from comments\nrule._selector.raw //=> 'a /**/ b' original raw value\n```\n\nBut PostCSS preservers the raw content in order to stringify it back to CSS,\nin case you don’t change the original value. In general, PostCSS tries\nto preserve the original CSS byte-to-byte whenever possible:\n\n```js\nrule.toString() //=> 'a /**/ b {}' with comment\n\nrule.selector = '.link b';\nrule.toString() //=> '.link b {}' you change value and origin comment was gone\n```\n\n### Containers\n\n`Root`, `AtRule` and `Rule` nodes can contain children in `nodes` property.\n\nThere are some common methods to perform work on children:\n\n* `append(newChild)` adds a child at the end of the children list.\n* `prepend(newChild)` adds a child at the beginning of the children list.\n* `insertBefore(existsChild, newChild)` inserts a new child before a\n   pre-existing child.\n* `insertAfter(existsChild, newChild)` inserts a new child after some\n   pre-existing child.\n* `remove(existsChild)` removes a child.\n* `removeAll()` to remove all children.\n* `index(existsChild)` returns a child’s index.\n* `some(fn)` returns true if `fn` returns true for any child.\n* `every(fn)` returns true if `fn` returns true for all children.\n\nMethods `append`, `prepend`, `insertBefore` and `insertAfter` will also accept\narrays and `Root` nodes as an argument.\n\nMethods `insertBefore`, `insertAfter` and `remove` will accept child nodes\nor indexes as the `existsChild` argument. Note that providing a child index will\nresult in the method completing much faster.\n\nYou can combine `node.clone()` and `node.parent.insertBefore()`\nby `node.cloneBefore()` and `node.cloneAfter()` methods.\n\nThere are two shortcuts to provide the first and last child of a node:\n\n```js\nrule.first //=> First declaration in rule\nrule.last  //=> Last declaration in rule\n```\n\n### Children\n\n`Comment`, `AtRule`, `Rule` and `Declaration` nodes should be wrapped\nin other nodes.\n\nAll children contain a `parent` property which indicates the parent node:\n\n```js\nrule.nodes[0].parent == rule;\n```\n\nAll children have a `removeSelf()` method:\n\n```js\nrule.nodes[0].removeSelf();\n```\n\nBut invoking the `remove(index)` method on the parent is much faster:\n\n```js\nrule.each(function (decl, i) {\n    rule.remove(i);\n});\n```\n\nYou can move nodes between parents by `moveTo()`, `moveBefore()`\nand `moveAfter()` methods.\n\nTo replace node by other one use `node.replaceWith(other)` method.\n\nMethods `prev()` and `next()` returns previous and next child in node parent.\n\n### Iterators\n\nAll parent nodes have an `each` method which allows you to iterate over\nits child nodes:\n\n```js\nroot = postcss.parse('a { color: black; display: none }');\n\nroot.each(function (rule, i) {\n    if ( rule.type == 'rule' ) {\n        console.log(rule.selector, i); // Will log \"a 0\"\n    }\n});\n\nroot.first.each(function (decl, i) {\n    if ( rule.type != 'comment' ) {\n        console.log(decl.prop, i); // Will log \"color 0\" and \"display 1\"\n    }\n});\n```\n\nUnlike `for {}`-cycle construct or `Array#forEach()` this iterator is safe.\nSo you can mutate the children during iteration and PostCSS will fix\nthe current index:\n\n```js\nrule.nodes.forEach(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will infinitely cycle as prepending the current declaration will\n    // cause the second and successive indexes to interact with the\n    // current declaration endlessly\n});\n\nrule.each(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will work correctly (each declaration will be cloned only once),\n    // because the iterator index will be recalculated only after the prepend\n});\n```\n\nBecause CSS has a nested structure, PostCSS also features a recursive iterator\n`eachInside`:\n\n```js\nroot.eachInside(function (node, i) {\n    console.log(node.type + ' inside ' + node.parent.type);\n});\n```\n\nThere are also shortcuts so that you can recursively iterate over nodes\nof a specific type:\n\n```js\nroot.eachDecl(function (decl, i) {\n    // Each declaration inside root\n});\n\nroot.eachRule(function (rule, i) {\n    // Each rule inside root and any nested at-rules\n});\n\nroot.eachAtRule(function (atRule, i) {\n    // Each at-rule inside root and any nested at-rules\n});\n\nroot.eachComment(function (comment, i) {\n    // Each comment inside root\n})\n```\n\nMethods `eachDecl()` and `eachAtRule()` also accept a string or regexp\nfilter to only iterate over declarations with some property name\nor for at-rules with some name.\n\n```js\nroot.eachDecl(/^background/, function (decl) {\n    inlineImages(decl);\n});\n```\n\nYou can break out from the iteration by returning `false`.\n\nIf you want to change values in all children, you can use very `replaceValues`\nmethod:\n\n```js\nroot.replaceValues(/\\d+(\\.\\d+)?rem/,\n    { props: ['width', 'height'], fast: 'rem' }, function (str) {\n        var rem = parseFloat(str);\n        return 16 * rem;\n    })\n```\n\nOption `fast` will be used for fast precheck by `indexOf()`.\n\n### Root Node\n\n`Root` node contains the entire CSS tree. Its children can only be `Comment`,\n`AtRule`, or `Rule` nodes in the `nodes` property.\n\nYou can create a new root using the shortcut:\n\n```js\nvar root = postcss.root();\n```\n\nMethod `toString()` stringifies the entire node tree and returns a CSS string:\n\n```js\nroot = postcss.parse(css);\nroot.toString() == css;\n```\n\nIf PostCSS found previous source map, it will save all the relevant information\nwithin `Root#prevMap`:\n\n```\nroot = postcss.parse(css);\nif (root.prevMap && root.prevMap.inline) {\n    console.log('Inlined map: ' + root.prevMap.annotation)\n}\n```\n\n### Comment Node\n\n```css\n/* Block comment */\n```\n\nPostCSS creates `Comment` nodes only for comments found between rules\nor declarations. Comments found within selectors, at-rules params,\nor declaration values will be stored in the Raw property.\n\n`Comment` has only one property: `text` which contains the trimmed text inside\nthe comment.\n\n```js\ncomment.text //=> \"Block comment\"\n```\n\nYou can create a new comment using a shortcut:\n\n```js\nvar comment = postcss.comment({ text: 'New comment' });\n```\n\n### AtRule Node\n\n```css\n@charset 'utf-8';\n\n@font-face {\n    font-family: 'Cool'\n}\n\n@media print {\n    img { display: none }\n}\n```\n\n`AtRule` has two own properties: `name` and `params`.\n\nAs illustrated above, some at-rules do not contain any children\n(for example, `@charset` or `@import`), some at-rules can only contain\ndeclarations (for example, `@font-face` or `@page`), but most of them\ncan contain rules and nested at-rules (for example, `@media`, `@keyframes`\nand others).\n\nYou can create a new at-rule using a shortcut:\n\n```js\nvar atRule = postcss.atRule({ name: 'charset', params: 'utf-8' });\n```\n\n### Rule Node\n\n```css\na {\n    color: black;\n}\n```\n\n`Rule` nodes have a `selector` property and contain their `Declaration`\nand `Comment` children within the `nodes` property.\n\nThey also possess a `selectors` shortcut, which returns an array:\n\n```js\nrule.selector  //=> \"a, b\"\nrule.selectors //=> ['a', 'b']\n```\n\nYou can avoid using the `Declaration` constructor for `append`\nand other insert methods, by:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n\nThe property `semicolon` indicates if the last declaration within the rule has\na semicolon or not:\n\n```js\nvar root = postcss.parse('a { color: black }');\nroot.first.semicolon //=> false\n\nvar root = postcss.parse('a { color: black; }');\nroot.first.semicolon //=> true\n```\n\nYou can create a new rule using a shortcut:\n\n```js\nvar rule = postcss.rule({ selector: 'a' });\n```\n\n### Declaration Node\n\n```css\ncolor: black\n```\n\n`Declaration` nodes have `prop`, `value` and `important` properties.\n\nYou can create a new declaration using a shortcut:\n\n```js\nvar decl = postcss.decl({ prop: 'color', value: 'black' });\n```\n\nOr you can use the short form available via a rule’s `append()` and other\nadd methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/postcss/postcss/issues"
  },
  "homepage": "https://github.com/postcss/postcss",
  "_id": "postcss@4.0.1",
  "dist": {
    "shasum": "02f7e6409c8ae885f75694474170f7aeed111bb5"
  },
  "_from": "postcss@~4.0.1",
  "_resolved": "https://registry.npmjs.org/postcss/-/postcss-4.0.1.tgz"
}
